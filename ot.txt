Timer unit: 1e-06 s

Total time: 0.006801 s
File: /home/iteki/Asahi/endpoints/web.py
Function: getMapScores at line 217

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   217                                           @web.route("/web/osu-osz2-getscores.php")
   218                                           @profile
   219                                           async def getMapScores():
   220         3         52.0     17.3      0.8      args = request.args
   221         3         69.0     23.0      1.0      if not auth(args['us'], args['ha']):
   222                                                   return Response(b'', status=400)
   223                                           
   224         3         15.0      5.0      0.2      if (md5 := args['c']) in glob.cache['unsub']:
   225                                                   return b'-1|false' # tell client map is unsub xd
   226                                           
   227         3         17.0      5.7      0.2      mods = int(args['mods'])
   228         3         97.0     32.3      1.4      mode = lbModes(int(args['m']), mods)
   229         3         12.0      4.0      0.2      sid = int(args['i'])
   230         3         12.0      4.0      0.2      lb = int(args['v'])
   231                                           
   232         3         40.0     13.3      0.6      player = g.pop("player")
   233                                           
   234         3         25.0      8.3      0.4      if mode.value != player.mode or mods != player.mods:
   235                                                   player.mode = mode.value
   236                                                   player.mods = mods
   237                                                   for o in glob.players.values():
   238                                                       o.enqueue(packets.userStats(player))
   239                                           
   240         3         20.0      6.7      0.3      if not (bmap := Beatmap.md5_cache(md5)):
   241         1        373.0    373.0      5.5          if not (bmap := await Beatmap.md5_sql(md5)):
   242                                                       if sid != -1:
   243                                                           await Beatmap.cache(sid)
   244                                                           bmap = Beatmap.md5_cache(md5)
   245                                                       else:
   246                                                           bmap = await Beatmap.md5_api(md5)
   247                                           
   248         1          4.0      4.0      0.1          if not bmap:
   249                                                       file = args['f'].replace('+', '')
   250                                                       reg = re.compile(r'^(?P<artist>.+) - (?P<title>.+) \((?P<mapper>.+)\) \[(?P<diff>.+)\]\.osu$') # fuck sake osu why do this to me
   251                                                       if not (info := reg.match(unquote(file))): # once again osu why
   252                                                           # invalid file? idfk
   253                                                           glob.cache['unsub'].append(md5)
   254                                                           return b'-1|false'
   255                                           
   256                                                       exists = await glob.db.fetchval('SELECT 1 FROM maps WHERE artist = $1 AND title = $2 AND diff = $3 AND mapper = $4', info['artist'], info['title'], info['diff'], info['mapper'])
   257                                           
   258                                                       if exists:
   259                                                           return b'1|false' # bmap submitted but not up to date, send update available
   260                                                       else:
   261                                                           glob.cache['unsub'].append(md5)
   262                                                           return b'-1|false' # bmap or other version of bmap cannot be found, must be unsubmitted
   263                                           
   264         3         18.0      6.0      0.3      if not bmap.frozen and bmap.nc < time.time():
   265         3       3432.0   1144.0     50.5          await bmap.check_status()
   266                                           
   267         3         22.0      7.3      0.3      if bmap.status < mapStatuses.Ranked:
   268                                                   return f'{bmap.status}|false'.encode() # map is unranked, unsubmitted etc. then we return status with no scores or anything
   269                                           
   270         3          8.0      2.7      0.1      resp = []
   271                                           
   272         3          7.0      2.3      0.1      if lb == 2: # mod-specific lb
   273                                                   if base := bmap.lb_cache.get(mode):
   274                                                       if mods in base:
   275                                                           resp = base[mods] # no better conditional way to do this with a list(?)
   276                                                   
   277                                                   if not base or not mods in base:
   278                                                       scores = await glob.db.fetch(f'SELECT t.*, users.name FROM {mode.table} t LEFT OUTER JOIN users ON users.id = t.uid WHERE t.md5 = $1 AND t.status = 2 AND mode = $2 AND users.priv & 1 > 0 AND t.mods = $3 ORDER BY t.{mode.sort} DESC LIMIT 100', md5, int(args['m']), mods)
   279                                                       resp.append(f'{bmap.status}|false|{bmap.id}|{bmap.sid}|{len(scores)}')
   280                                                       resp.append(f'0\n{bmap.name}\n10.0') # why osu using \n :( | force 10.0 rating cus no ratings rn, 0 is map offset (probably wont ever be used)
   281                                                       if not scores:
   282                                                           bmap.lb_cache[mode][mods] = resp[:]
   283                                                           return '\n'.join(resp).encode()
   284                                           
   285                                                   best = await glob.db.fetchrow(f'SELECT t.* FROM {mode.table} t WHERE md5 = $1 AND mode = $2 AND uid = $3 AND status = 2 AND mods = $4 ORDER BY t.{mode.sort} DESC LIMIT 1', md5, int(args['m']), player.id, mods)
   286                                                   if best:
   287                                                       b_rank = await glob.db.fetchrow(f'SELECT COUNT(*) AS rank FROM {mode.table} t LEFT OUTER JOIN users ON users.id = t.uid WHERE md5 = $1 AND mode = $2 AND status = 2 AND users.priv & 1 > 0 AND t.{mode.sort} > $3', md5, int(args['m']), best[mode.sort])
   288                                                       rank = b_rank['rank'] + 1
   289                                           
   290                                                       resp.insert(2, f'{best["id"]}|{player.name}|{int(best[mode.sort])}|{best["combo"]}|{best["n50"]}|{best["n100"]}|{best["n300"]}|{best["miss"]}|{best["katu"]}|{best["geki"]}|{best["fc"]}|{best["mods"]}|{player.id}|{rank}|{best["time"]}|"1"')
   291                                                   else:
   292                                                       resp.insert(2, '')
   293                                           
   294                                                   if not base or not mods in base:
   295                                                       for rank, s in enumerate(scores):
   296                                                           resp.append(f'{s["id"]}|{s["name"]}|{int(s[mode.sort])}|{s["combo"]}|{s["n50"]}|{s["n100"]}|{s["n300"]}|{s["miss"]}|{s["katu"]}|{s["geki"]}|{s["fc"]}|{s["mods"]}|{s["uid"]}|{rank + 1}|{s["time"]}|"1"')
   297                                           
   298                                                   if not base or not mods in base:
   299                                                       bmap.lb_cache[mode][mods] = resp[:] # set cache to current lb
   300                                                       bmap.lb_cache[mode][mods].remove(bmap.lb_cache[mode][mods][2]) # remove personal best since it will differ per user
   301                                           
   302                                                   return '\n'.join(resp).encode()
   303                                               else:
   304         3         25.0      8.3      0.4          if bmap.lb_cache.get(mode):
   305         2          8.0      4.0      0.1              resp = bmap.lb_cache[mode][:]
   306                                           
   307         3         10.0      3.3      0.1          if not bmap.lb_cache.get(mode):
   308         1        400.0    400.0      5.9              scores = await glob.db.fetch(f'SELECT t.*, users.name FROM {mode.table} t LEFT OUTER JOIN users ON users.id = t.uid WHERE t.md5 = $1 AND t.status = 2 AND mode = $2 AND users.priv & 1 > 0 ORDER BY t.{mode.sort} DESC LIMIT 100', md5, int(args['m']))
   309         1         18.0     18.0      0.3              resp.append(f'{bmap.status}|false|{bmap.id}|{bmap.sid}|{len(scores)}')
   310         1          8.0      8.0      0.1              resp.append(f'0\n{bmap.name}\n10.0') # why osu using \n :( | force 10.0 rating cus no ratings rn, 0 is map offset (probably wont ever be used)
   311         1          3.0      3.0      0.0              if not scores:
   312         1          5.0      5.0      0.1                  bmap.lb_cache[mode] = resp[:]
   313         1          4.0      4.0      0.1                  return '\n'.join(resp).encode()
   314                                           
   315         2       1076.0    538.0     15.8          best = await glob.db.fetchrow(f'SELECT t.* FROM {mode.table} t WHERE md5 = $1 AND mode = $2 AND uid = $3 AND status = 2 ORDER BY t.{mode.sort} DESC LIMIT 1', md5, int(args['m']), player.id)
   316         2          7.0      3.5      0.1          if best:
   317         2        954.0    477.0     14.0              b_rank = await glob.db.fetchrow(f'SELECT COUNT(*) AS rank FROM {mode.table} t LEFT OUTER JOIN users ON users.id = t.uid WHERE md5 = $1 AND mode = $2 AND status = 2 AND users.priv & 1 > 0 AND t.{mode.sort} > $3', md5, int(args['m']), best[mode.sort])
   318         2          9.0      4.5      0.1              rank = b_rank['rank'] + 1
   319                                           
   320         2         28.0     14.0      0.4              resp.insert(2, f'{best["id"]}|{player.name}|{int(best[mode.sort])}|{best["combo"]}|{best["n50"]}|{best["n100"]}|{best["n300"]}|{best["miss"]}|{best["katu"]}|{best["geki"]}|{best["fc"]}|{best["mods"]}|{player.id}|{rank}|{best["time"]}|"1"')
   321                                                   else:
   322                                                       resp.insert(2, '')
   323                                           
   324         2          8.0      4.0      0.1          if not bmap.lb_cache.get(mode):
   325                                                       for rank, s in enumerate(scores):
   326                                                           resp.append(f'{s["id"]}|{s["name"]}|{int(s[mode.sort])}|{s["combo"]}|{s["n50"]}|{s["n100"]}|{s["n300"]}|{s["miss"]}|{s["katu"]}|{s["geki"]}|{s["fc"]}|{s["mods"]}|{s["uid"]}|{rank + 1}|{s["time"]}|"1"')
   327                                                   
   328         2          7.0      3.5      0.1          if not bmap.lb_cache.get(mode):
   329                                                       bmap.lb_cache[mode] = resp[:] # set cache to current lb
   330                                                       bmap.lb_cache[mode].remove(bmap.lb_cache[mode][2]) # remove personal best since it will differ per user
   331                                           
   332         2          8.0      4.0      0.1          return '\n'.join(resp).encode()

